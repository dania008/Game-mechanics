# Game-mechanics

## heroscript.cs

### Минусы:
1. Нарушение принципа единственной ответственности (SRP, SOLID)

    Класс heroscript выполняет слишком много задач:
    - Управляет движением персонажа (бег, прыжок, поворот).
    - Работает с оружием (атака, смена оружия).
    - Отвечает за взаимодействие с другими объектами (монеты, книги).
    - Хранит ссылки на UI-элементы (джойстик, кнопки).
    - Управляет анимацией (Flip).

    Нужно разделить функционал на отдельные компоненты:
    - Компонент управления движением (MovementController).
    - Компонент управления атакой (AttackController).
    - Компонент взаимодействия с объектами (InteractionHandler).
    - Оставить heroscript как "главный" класс для соединения остальных компонентов.

2. Захардкоженные значения / магические числа

    Значения вроде скорости (0.18f, 3) или времени (0.15f) хардкодятся прямо в методах. Это делает код сложным для тестирования и изменения.

3. Сложная логика в Update

    Можно вынести логику в методы

4. Нарушение принципа открытости/закрытости (OCP, SOLID)

    Я прекрасно понимаю, что соблюдать на 100% его невозможно в проекте, но тут грубое нарушение.
    Метод Attack нарушает принцип, так как каждый раз при добавлении нового оружия приходится модифицировать switch. Это делает его сложно расширяемым.
    Нужно использовать паттерн "Стратегия" для оружия:
    - Создать интерфейс IWeapon с методом Attack().
    - Каждый вид оружия (Hammer, Broom, Egg) реализует свой класс.
    - В heroscript достаточно хранить ссылку на IWeapon и вызывать currentWeapon.Attack().

5. Нарушение принципа инверсии зависимостей (DIP, SOLID)

    heroscript напрямую зависит от множества компонентов (QueueManager, CameraControlla, MoneyManager), которые ищутся через FindObjectOfType или GameObject.Find. Это создает сильную связанность.
    Нужно использовать внедрение зависимостей (Dependency Injection):
    - Передавать ссылки на эти компоненты через конструктор или фабричный метод.
    - Например, можно использовать Unity-специфический подход с SerializedField.

6. Работа с тегами и именами объектов

    Поиск объектов через теги (GameObject.Find("Queue"), collision.tag) делает код ненадежным: если имя объекта изменится, скрипт перестанет работать.

7. Нарушение принципа DRY (Don’t Repeat Yourself)

    Логика движения (в Update, LeftGo, RightGo) и поворота (Flip) повторяется в разных местах.

8. Улучшение атаки

    Метод Attack слишком перегружен логикой для каждого оружия. У каждого оружия можно выделить отдельный класс.

9. Комментарии и названия

    Многие названия переменных, методов, и тп. а также комментарии избыточны или неинформативны

10. Стуктура иерархии кода

    - Соблюдение иерархиий:
    - 1) Публичные -> Приватные
    - 2) Переменные -> Конструктор -> Методы

### По итогу нужно:
- Разделить ответственность через отдельные компоненты.
- Убрать дублирование.
- Ввести систему для работы с оружием (интерфейсы, паттерн "Стратегия").
- Заменить хардкод на константы или ScriptableObject.
- Улучшить читаемость, разбив методы на меньшие части.
- Интегрировать внедрение зависимостей. А мб перейти на ECS ?? Нужно отталкиваться от подходов и архитектуры.
- Сократить зависимости от FindObject и GameObject.Find.
- Переписать корректные комментарии и нейминг.

## BirdHelperForPhone.cs

В целом, проблемы те же.

### Минусы:

1. Принцип единственной ответственности (SRP)

    Класс отвечает за слишком много задач:
    - Управление интерфейсом (тексты, кнопки).
    - Логика прыжков и силы.
    - Работа с сохранениями (PlayerPrefs).
    - Обработка столкновений.
    Это создает сильную связанность кода и усложняет его расширение.

Нужно разделить функционал на несколько компонентов:
    - UIHandler: Управление UI (тексты, кнопки, сохранение/загрузка алмазов).
    - JumpController: Логика прыжков (сила, модификация, обработка физики).
    - CollisionHandler: Логика обработки столкновений.

2. Дублирование кода

    Например:
    - Методы SaveGemsExit и SaveGemsExit_2 делают одно и то же, но с разными текстами.
    - Проверка состояния PlayerPrefs для прыжков, бонусов и огонька повторяется в OnEnable.

3. Захардкоженные строки и значения

    Строки вроде "ModeInGame1", "Skill_3_1", "Gem", "CheckPointValue" хранятся прямо в коде. Это затрудняет их изменение и добавление новых ключей.

4. Смешение данных и логики

    Переменная force управляется в PlusJump, MinusJump, Jump, что нарушает инкапсуляцию данных.

5. Обработка физики

    Метод Jump смешивает добавление силы и вращение. Логика вращения (MoveRotation) может быть вынесена в отдельный метод.

6. Комментарии

    Некоторые комментарии избыточны или не добавляют смысла.

### По итогу нужно:
- Разделить ответственность через отдельные компоненты.
- Убрать дублирование.
- Заменить хардкод на константы или ScriptableObject.
- Улучшить читаемость, разбив методы на меньшие части и распределив их на разную логику.
- Переписать корректные комментарии и нейминг.
